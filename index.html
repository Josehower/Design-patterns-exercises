<!DOCTYPE html>
<html>

<head>
</head>

<body>

  <h1>Maze Creator</h1>


  <script>
    /* eslint-disable class-methods-use-this */
    class MapSite {
      constructor() {
        if (this.constructor === MapSite) {
          throw 'this is an Abstrct Class';
        }
      }

      enter() {
        throw 'this method need to be implemented on each subClass';
      }
    }

    class Room extends MapSite {
      constructor() {
        super();
        this.name = `room${Room.prototype.conteo}`;
        this.roomNumber = Room.prototype.conteo;
        this.structure = {};
        console.log(`creating room number ${this.roomNumber}`);
        Room.prototype.conteo += 1;
      }

      clone() {
        const roomClone = new Room();
        return roomClone;
      }

      enter() {
        console.log(`your are now on room number ${this.roomNumber}`);
      }

      setSide(direction, MapSiteComponent) {
        if (
          !(
            direction === 'N' ||
            direction === 'S' ||
            direction === 'E' ||
            direction === 'W'
          )
        ) {
          throw 'you have to set a real direction N, S, E, or W';
        } else {
          this.structure[direction] = MapSiteComponent;
        }
      }

      getSide(direction) {
        if (
          !(
            direction === 'N' ||
            direction === 'S' ||
            direction === 'E' ||
            direction === 'W'
          )
        ) {
          throw 'you have to set a real direction N, S, E, or W';
        } else if (this[direction]) {
          console.log(this[direction].name);
        } else {
          console.log('nothing There');
        }
      }
    }

    Room.prototype.conteo = 1;

    class EnchantedRoom extends Room {
      constructor() {
        super();
        this.name = `enchanted room${this.roomNumber}`;
        console.log(`creating EnchantedRoom number ${this.roomNumber}`);
      }

      clone() {
        const roomClone = new EnchantedRoom();
        return roomClone;
      }
    }

    class Wall extends MapSite {
      constructor() {
        super();
        this.name = `Wall${Wall.prototype.conteo}`;
        this.wallNumber = Wall.prototype.conteo;
        console.log(`creating wall number ${this.wallNumber}`);
        Wall.prototype.conteo = +1;
      }

      clone() {
        const wallClone = new Wall();
        return wallClone;
      }
    }
    Wall.prototype.conteo = 1;

    class Door extends MapSite {
      constructor(roomA, roomB) {
        super();
        if (!(roomA && roomB)) {
          throw 'need two rooms';
        }

        this.name = `Door${Door.prototype.conteo}`;
        this.doorNumber = Door.prototype.conteo;
        this.between = [roomA.name, roomB.name];
        console.log(
          `creating door # ${this.doorNumber} between ${this.between[0]} and ${this.between[1]} `
        );
        Door.prototype.conteo += 1;
      }

      clone(roomA, roomB) {
        const doorClone = new Door(roomA, roomB);
        return doorClone;
      }
    }
    Door.prototype.conteo = 1;

    class DoorNeedingSpell extends Door {
      constructor(roomA, roomB) {
        super(roomA, roomB);
        this.name = `enchanted door${this.doorNumber}`;
        console.log(`creating EnchantedDoor number ${this.doorNumber}`);
        this.protectedBySpell = true;
      }

      clone(roomA, roomB) {
        const doorClone = new DoorNeedingSpell(roomA, roomB);
        return doorClone;
      }

      unlock(spell) {
        this.protectedBySpell = spell !== 'kadabra';
        console.log('you tried to unlock the door...');
      }
    }

    class Maze {
      constructor() {
        console.log(`creating a new Maze`);
        this.rooms = [];
      }

      clone(roomA, roomB) {
        const mazeClone = new Maze(roomA, roomB);
        return mazeClone;
      }

      addRoom(room) {
        this.rooms.push(room);
      }

      /* TODO: create search RoomNo. method */
    }

    class MazePrototypeFactory {
      constructor(maze, wall, room, door) {
        this.protoMaze = maze;
        this.protoRoom = room;
        this.protoWall = wall;
        this.protoDoor = door;
      }

      static actualInstance = null;

      static instantiate(maze, wall, room, door) {
        if (MazePrototypeFactory.actualInstance === null) {
          MazePrototypeFactory.actualInstance = new MazePrototypeFactory(
            maze,
            wall,
            room,
            door
          );
        } else {
          throw 'one instance of this maze is already running';
        }
        return MazePrototypeFactory.actualInstance;
      }

      makeMaze() {
        return this.protoMaze.clone();
      }

      makeWall() {
        return this.protoWall.clone();
      }

      makeRoom() {
        return this.protoRoom.clone();
      }

      makeDoor(room1, room2) {
        return this.protoDoor.clone(room1, room2);
      }
    }

    class EnchantedMazeFactory extends MazePrototypeFactory {
      constructor(maze, wall, room, door) {
        super(maze, wall, room, door);
        this.protoRoom = new EnchantedRoom();
        this.protoDoom = new DoorNeedingSpell(this.protoRoom, this.protoRoom);
      }

      static actualInstance = null;

      static instantiate(maze, wall, room, door) {
        if (EnchantedMazeFactory.actualInstance === null) {
          EnchantedMazeFactory.actualInstance = new EnchantedMazeFactory(
            maze,
            wall,
            room,
            door
          );
        } else {
          throw 'one instance of this enchanted maze is already running';
        }
        return EnchantedMazeFactory.actualInstance;
      }
    }

    class MazeGame {
      constructor() {
        console.log(`creating a new MazeGame`);
      }

      createMaze(mazeFactory) {
        const myMaze = mazeFactory.makeMaze();
        const r1 = mazeFactory.makeRoom();
        const r2 = mazeFactory.makeRoom();
        const theDoor = mazeFactory.makeDoor(r1, r2);

        myMaze.addRoom(r1);
        myMaze.addRoom(r2);

        r1.setSide('N', mazeFactory.makeWall());
        r1.setSide('E', theDoor);
        r1.setSide('S', mazeFactory.makeWall());
        r1.setSide('W', mazeFactory.makeWall());

        r2.setSide('N', mazeFactory.makeWall());
        r2.setSide('E', mazeFactory.makeWall());
        r2.setSide('S', mazeFactory.makeWall());
        r2.setSide('W', theDoor);
        return myMaze;
      }
    }

    class InitGame {
      constructor(param = 'N') {
        const myMazeGame = new MazeGame();
        const maze = new Maze();
        const wall = new Wall();
        const room = new Room();
        const door = new Door(room, room);
        const factory =
          param === 'N'
            ? MazePrototypeFactory.instantiate(maze, wall, room, door)
            : EnchantedMazeFactory.instantiate(maze, wall, room, door);
        return myMazeGame.createMaze(factory);
      }
    }

    const myInit = new InitGame();
    const myEnchantedInit = new InitGame('E');
    console.log(myInit);
    console.log(myEnchantedInit);
  </script>
</body>

</html>